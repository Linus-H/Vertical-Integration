# `cases`
This folder contains a folder structure with a number of already implemented PDEs.
To this end, every implemented case contains the following items:
* `derivative.py` This file contains at least one class implementing the time-derivative for the PDE.
Its `__call__`-method will be called repeatedly by the integrator-class at simulation-time, and is only allowed to receive two parameters:
a numpy-array containing all the state-variables (first dimension specifies the variable, second dimension specifies the spacial location), and the current time in order to make time-dependent PDEs possible.
* `solution.py` In case an analytical solution for a problem is known, a class inheriting from `utils.Solution` is supposed to be implemented in this file.
The first three parameters of its constructor always have to be:
    * `num_grid_points` the number of grid-points used for the solution
    * `dt` the time-step size the solution is supposed to use. This is necessary, because inheriting from utils.Solution makes the class into a python-iterator, which increases its internal time by `dt` every iteration.
    * `domain_size` the size of the domain the solution is supposed to have
* `run.py` This file is supposed to set up all the parameters for simulating the PDE, and then call an appropriate function from `cases/run_utils.py` to run a simulation.
* `test.py` This file contains unit-tests for the PDE, to verify its implementation.
In case an analytical solution is known and implemented in `simulation.py`, it can be used to be checked against.
Otherwise a numerical reference solution can be generated using `cases/numerical_ref_solution.py`.

The order of some inputs to some functions of some functions have been specified in order to enable other parts of the project to use all PDE-implementations the same way.

## How-To: setup a run.py file
The aim of a `run.py`-file is to execute one of the functions in `run_utils.py` in order to run a simulation.
The inputs of all functions in `run_utils.py` follow a similar scheme:
1. `params` a dictionary containing parameters for the simulation.
This dictionary always has to contain parameters for `'dt'` (step size per iteration made in the simulation),`'num_grid_points'` (number of grid points each of the system variables should have),`'domain_size'` (size of the domain 0...`'domain_size'` each of the variables should occupy).
2. `integrator_class` class of the integrator to be used for the simulation.
The parameters it needs to be instantiated will be generated by the function.
3. `time_derivative_class` class of the time-derivative class to be used for the simulation.
As all such classes have the same first three inputs (see above), they will be filled in by the function using information from `params`.
All remaining inputs for instantiation need to be supplied using the following:
4. `time_derivative_inputs` contains all remaining inputs for the `time_derivative_class` as a list.
5. further inputs that depend on the function.
For the remaining inputs identify what case is desired:
    * visual feedback desired: `params` needs to contain a value for `'sampling_rate'`, which specifies the number of iterations to be performed before the visuals should be updated.
        * solution is known &rarr; `run_visual_with_solution`.\
        The remaining two inputs to `run_visual_with_solution` are:
            * `case_solution_class` class of the solution. Like `time_derivative_class` its standard inputs are supplied by the function. All further inputs are given by: 
            * `case_sol_inputs` a list of all further inputs the case solution-class needs.
        * no solution is known &rarr; use `run_visual_without_solution`.\
        The remaining input to the function is an instance of the `utils.State`-class, which specifies the starting condition of the simulation.
    * visual feedback is not desired, but instead the accuracy/error of the simulation should be determined &rarr; `gen_test_data`.
    `params` needs to contain a value for `'end_time'`, which specifies at what point in time the simulation should be stopped in order to determine the error between the simulation and the solution:
        * a solution is known: the remaining inputs are the same as for `run_visual_with_solution`.
        * no solution is known: A numerical reference solution needs to be generated. This means RK4 will be used with very small time-steps to run a simulation and the time-traces will be stored to the disk.
        This can be done using `numerical_ref_solution.py`.
        To this end, an instance of `ReferenceSolutionCalculator` needs to be created (for parameters refer to the documentation).
        Then as input for the parameter `case_solution_class`, use `numerical_ref_solution.CaseSolution`.
        For `case_sol_inputs` the input needs to be a list of the following form:
        [number of variables; instance of the `ReferenceSolutionCalculator`; list of functions which specify the initial conditions, with len=number of variables; desired time-step-size of the ('exact') numerical reference solution; time up to which the reference solution shall be run]
### Example: wave_equation/wrap_around/derivative
1. setting up params
    ```
    params = {
       'num_grid_points': 100,
       'domain_size': 1.0,
       'dt': 1e-5
       }
    ```
2. choosing an integrator
    ```
    integrator_class = integrators.RungeKutta.Explicit
    ``` 
3. specifying the time derivative
    ```
    time_derivative_class = cases.wave_equation.wrap_around.derivative.derivative.TimeDerivative
    ``` 
4. this time derivative needs a special input, namely the wave speed $$c$$
    ```
    time_derivative_inputs = [c]
    ```
5. We want to run with a visual and we also have a solution, so we need to add a value `'sampling_rate'`, and also have to specify the `case_solution_class` and its special inputs `case_sol_inputs`.
These are the wave speed and a function for the starting condition.
For this we will use a function from `starting_conditions.py`
    ```
    params['sampling_rate'] = 50
    case_solution_class = cases.wave_equation.wrap_around.derivative.solution.CaseSolution
    start_cond = GaussianBump(params['domain_size'] * 0.5, 100)
    case_sol_input = [c, start_cond.start_cond]
    ```
6. Now we just have to start the simulation:
    ```
    run_utils.run_visual_with_solution(params, integrator_class,
                                   time_derivative_class, time_derivative_inputs,
                                   case_solution_class, case_sol_input)

    ```

## Folder descriptions
* `debug_case` This folder is different from the others because it only contains one-dimensional PDEs (only one variable with only one dimension), which are used to debug the integrators.
* `euler_equation/_1D` This folder contains a 1-dimensional version of the Euler-Equations with gravitation and viscosity.
There are two implementations, one using $$\rho$$ directly, and one using $$ln\rho$$ instead.
In latter implementation, non-linear terms and viscosity can be disabled.
* `wave_equation` This folder contains different implementations of the standard wave-equation: $$\frac{d^{2}u}{dt^{2}}&=c^{2} \cdot \frac{d^{2}u}{dx^{2}}$$.
As different implementations and boundary conditions are possible, this folder contains multiple implementations:
    * `dirichlet` makes the assumption that the velocity $$\frac{du}{dt}$$ at the locations 0 and L is zero, thus fixing u to a static value, which is a Dirichlet-boundary condition. This leads to solutions that can be found using Fourier-Analysis.
    * `neumann` makes the assumption that the ends are free. This is achieved by 'pretending' that the domain is mirrored at its borders, which leads to the spacial derivative being fixed to a value of zero, which is a Neumann boundary condition.
    * `periodic` makes the assumption that the domain is circular/periodic, i.e. one can pretend an infinite amount of identical domains attached to each other at their sides.
        * `derivative` Implements the wave equation using only first-order derivatives and introducing a second variable $$\frac{dv}{dt} = c^2 \frac{du}{dx}$$
        * `laplace` Implements the wave equation using only second-order derivatives (laplacians), and introducing a second variable $$\frac{du}{dt} = v$$
        * `staggered_grid_derivative` Makes the same ansatz as `derivative`, but staggers the two variables $$u$$ and $$v$$ onto two different grids.

## File descriptions
* `run_utils.py` contains three functions, which are used to run a simulation.
    * `gen_test_data` used when a solution is known (can also be numerical), and we want to see how far away our simulated results are.
    * `run_visual_with_solution` used when a solution is known and a visual is desired.
    For each variable this function will display in a column the solution, the simulated result, the difference between the solution and the result, and a graph tracking the error over time.
    This is intended for debugging.
    * `run_visual_without_solution` used when no solution is known and a visual is desired. This will display all variables of the the simulated result in a column.

* `numerical_ref_solution.py` This file contains two classes to generate numerical results which will be stored in the folder `utils.data_path` (**warning: these files may be very large (a couple of GB)**:
    * `ReferenceSolutionCalculator` In its constructor it receives the parameters it is supposed to use for its simulation, which it will execute using RK4 as soon as its `generate`-method is called.
    * `CaseSolution` Inherits from `utils.Solution`. Besides the usual input for such classes, it receives an instance of `ReferenceSolutionCalculator`, a list of functions to setup the initial conditions for the PDE, the step-size the numerical solution is supposed to use, and the time at which the reference solution shall terminate.